Package frank;

Helpers
 digito         = ['0' .. '9'];
 espaco         = ' ';
 rc             = 13;
 nl             = 10;
 tb             = 9;
 letraminuscula = ['a' .. 'z'];
 letramaiuscula = ['A' .. 'Z'];
 letra          = (letraminuscula | letramaiuscula);
 underline      = '_';
 all_char       = [0 .. 254];
 letra_hexa     = (['a'..'f'] | ['A'..'F']);
 not_star       = [all_char-'*'];
 not_star_slash = [not_star-'/'];
 
Tokens
 number_decimal = digito+;
 number_real    = digito+'.'digito+;
 number_hexa    = '0''x'(digito | letra_hexa)+; 
 plus           = '+';
 minus          = '-';
 mult           = '*';
 div            = '/';
 mod            = '%';
 
 atribuicao     = ':''=';
 menor          = '<';
 igual          = '=';
 not            = '!';
 and            = 'a''n''d';
 or             = 'o''r';
 true			= 't''r''u''e';
 false 			= 'f''a''l''s''e';
 
 vert_bar 	    = '|';
 l_par          = '(';
 r_par          = ')';
 virgula        = ',';
 final_linha    = ';';
 l_col          = '[';
 r_col          = ']';
 l_chaves       = '{';
 r_chaves       = '}';
 
 blank          = (espaco | rc | nl | tb)+;
 if             = 'i''f';
 then           = 't''h''e''n';
 else           = 'e''l''s''e';
 while          = 'w''h''i''l''e';
 
 int            = 'i''n''t';
 bool           = 'b''o''o''l';
 real           = 'r''e''a''l';
 function       = 'f''u''n''c''t''i''o''n';
 procedure      = 'p''r''o''c''e''d''u''r''e';
 print		    = 'p''r''i''n''t';
 size		    = 's''i''z''e';
 read		    = 'r''e''a''d';
 
 var            = 'v''a''r';
 cons           = 'c''o''n''s';
 
 identificador  = (underline | letra)(underline | letra | digito)*;
 
 comment_block  = '/''*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
 comment_line   = '/''/' [all_char - ['/'+nl]]* nl;
 

Ignored Tokens
 blank,
 comment_block,
 comment_line;

Productions

 programa = {decs} dec_var_const* dec_proc_fun*;
 dec_var_const = {variavel} dec_var | {const} dec_const;
 
 dec_var = {dec} var declaracao;
 
 dec_const = {constante} cons declaracao;
 
 declaracao = {declaracao} tipo id_inicializacao outras_declaracoes* final_linha;
 outras_declaracoes = {varios} virgula id_inicializacao;
 id_inicializacao = {id} identificador | {inicial} inicializacao;
 
 inicializacao = {inicializacao} identificador atribuicao tipo_exp;
  
 tipo_exp = {expressao} exp | {array_ext} array_ext | {array_comp} array_comp;
 
 array_ext = l_col r_col; //Completar depois
 array_comp = l_col r_col; //Completar depois
 
 tipo = {tipobase} tipo_base | {tipocomposto} tipo_base l_col exp r_col;
 
 tipo_base = {inteiro} int |
 			 {real} real |
 			 {boleano} bool;
 			 	
 dec_proc_fun = {proc} dec_proc | {fun} dec_fun;
 dec_proc = procedure identificador l_par parametros r_par comando;
 dec_fun = function tipo identificador l_par parametros r_par exp;
 
 parametros = {vazio} | {parametros} parametro outros_parametros*;
 outros_parametros = virgula parametro;  
 parametro = l_col var r_col tipo_parametro identificador;
 
 tipo_parametro = {tipobase} tipo_base | {tipo_parametro} tipo_parametro l_col r_col;
 
 //Completar depois abaixo
 comando =  
  	 {bloco} bloco; 
  
 bloco = l_chaves dec_var_const* comando r_chaves; //Verificar se isto ta certo com a prof eh assim q esta no pdf
 
 numeral = {int}number_decimal | {real}number_real | {hexa}number_hexa;
 
 //DÃºvida pra tirar: pq tem um if then else no exp?
 exp = 
 	{numero}numeral | {verdade}true | {falso}false | 
 	{chamda} chamada | {menos} minus exp | {bloco_exp} bloco_exp |
 	{expcalculo} cal_exp | {expbool} bool_exp;
 	
 
 bloco_exp = l_chaves dec_const* exp r_chaves;
 
 cal_exp = 
	 {soma_recursao} cal_exp soma termo | {termo_base}termo;
	 soma = {mais} plus | {menor}minus;
	 termo = {termo_recursao} termo mult_div fator | {fator_base}fator;
	 mult_div = {vezes} mult | {divisao} div | {modulo} mod;
	 fator = {com_parentes} l_par exp r_par | {numero} numeral;
 
 bool_exp = ; // Fazer depois
 
 chamada = ; //Fazer depois
   